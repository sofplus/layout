function .tetris_load(~slot)
{
	sp_sc_func_exec fn_tet_OneTimeVars
}


//x==4 is the location where the 'rotTile' is spawned
function fn_tet_OneTimeVars
{
	set _tet_bool "0"
	//used to say if a frame is used to spend creating a shape, dont apply gravity here
	set _tet_spawn "0"

	set _tet_jug_width "10"
	set _tet_jug_height "19" //18+1 offscreen at top to allow instant rotation

	set _tet_loop_run "0"
	set _tet_loop_busy "0"
	set _tet_loop_speed "500"
}

function fn_tet_ReloadGame
{
	//clear entire jug
	set ~i 0
	sp_sc_flow_while number cvar ~i < cvar _tet_jug_height
	{
		set _tet_jug_line_$i "0000000000"
		add ~i 1
	}

	zero _tet_seg_1_x;zero _tet_seg_1_y
	zero _tet_seg_2_x;zero _tet_seg_2_y
	zero _tet_seg_3_x;zero _tet_seg_3_y
	zero _tet_seg_4_x;zero _tet_seg_4_y

	zero _tet_seg_base
}
//shapes defined from left to right in chain if possible
function fn_tet_Spawn()
{
	sp_sc_cvar_random_int ~rand 1 7

	//square
	sp_sc_flow_if number cvar ~rand == val "1"
	{
		set _tet_seg_1_x "4";set _tet_seg_1_y "17"
		set _tet_seg_2_x "4";set _tet_seg_2_y "16"
		set _tet_seg_3_x "5";set _tet_seg_3_y "17"
		set _tet_seg_4_x "5";set _tet_seg_4_y "16"
		//there is no base(special case for square)
		set _tet_seg_base "0"
	}
	//middle_finger
	sp_sc_flow_if number cvar ~rand == val "2"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "17"
		set _tet_seg_2_x "4";set _tet_seg_2_y "17"
		set _tet_seg_3_x "4";set _tet_seg_3_y "16"
		set _tet_seg_4_x "5";set _tet_seg_4_y "17"
		set _tet_seg_base "2"
	}
	//z
	sp_sc_flow_if number cvar ~rand == val "3"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "17"
		set _tet_seg_2_x "4";set _tet_seg_2_y "17"
		set _tet_seg_3_x "4";set _tet_seg_3_y "16"
		set _tet_seg_4_x "5";set _tet_seg_4_y "16"
		set _tet_seg_base "2"
	}
	//L
	sp_sc_flow_if number cvar ~rand == val "4"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "16"
		set _tet_seg_2_x "3";set _tet_seg_2_y "17"
		set _tet_seg_3_x "4";set _tet_seg_3_y "17"
		set _tet_seg_4_x "5";set _tet_seg_4_y "17"
		set _tet_seg_base "3"
	}
	//s
	sp_sc_flow_if number cvar ~rand == val "5"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "16"
		set _tet_seg_2_x "4";set _tet_seg_2_y "17"
		set _tet_seg_3_x "4";set _tet_seg_3_y "16"
		set _tet_seg_4_x "5";set _tet_seg_4_y "17"
		set _tet_seg_base "2"
	}
	//line
	sp_sc_flow_if number cvar ~rand == val "6"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "16"
		set _tet_seg_2_x "4";set _tet_seg_2_y "16"
		set _tet_seg_3_x "5";set _tet_seg_3_y "16"
		set _tet_seg_4_x "6";set _tet_seg_4_y "16"
		set _tet_seg_base "2"
	}
	//reversed L
	sp_sc_flow_if number cvar ~rand == val "7"
	{
		set _tet_seg_1_x "3";set _tet_seg_1_y "16"
		set _tet_seg_2_x "4";set _tet_seg_2_y "16"
		set _tet_seg_3_x "5";set _tet_seg_3_y "16"
		set _tet_seg_4_x "5";set _tet_seg_4_y "17"
		set _tet_seg_base "2"
	}
}
//0=empty
//1=red(square)
//2=yellow(_|_)
//3=green(z)
//4=blue(L)
//5=lightblue(s)
//6=orange(line)
//7=pink(reversed L)
function fn_tet_WriteToJug(~x,~y,~val)
{
	//get what is before insert point
	sp_sc_cvar_substr ~tmp _tet_jug_line_$~y 0 #~x
	//append new value to that
	sp_sc_cvar_append ~tmp #~val
	//get what is after insert point
	add ~x 1;sp_sc_cvar_copy ~tmp3 _tet_jug_width;sp_sc_cvar_math_sub ~tmp3 #~x;sp_sc_cvar_substr ~tmp2 _tet_jug_line_$~y #~x #~tmp3
	//append that to the tmp cvar
	sp_sc_cvar_append ~tmp #~tmp2
}

//checks the location for out of bounds
//or already occupied..(not empty)
function fn_tet_DoesCollide(~x,~y)
{
	sp_sc_flow_if number cvar ~x < val "0"
	{
		set bool 1
	}
	else
	{
		sp_sc_flow_if number cvar ~x > val "18"
		{
			set bool 1
		}
		else
		{
			sp_sc_flow_if number cvar ~y < val "0"
			{
				set bool 1
			}
			else
			{
				//out of bound checks complete
				//now focus on jug comparisons
				sp_sc_cvar_substr ~tmp _tet_jug_line_$~y #~x 1
				sp_sc_flow_if number cvar ~tmp != val "0"
				{
					set bool 1
				}
				else
				{
					set bool 0
				}
			}
		}
	}
}

//will safely start a loop if one not already started
function .tetris_start(~slot)
{
    sp_sc_flow_if number cvar _tet_loop_busy == val "1"
    {
        say "please wait for current timer to unload"
    }
    else
    {
    	sp_sc_func_exec fn_tet_ReloadGame
    	set _tet_spawn "1"
        set _tet_loop_run "1"
        set _tet_loop_busy "1"
        sp_sc_func_exec fn_tet_loop
    }
}

//will stop a loop if one is running
function .tetris_stop(~slot)
{
    sp_sc_flow_if number cvar _tet_loop_busy == val "1"
    {
        set _tet_loop_run "0"
    }
}

//this is the heart of the game
function fn_tet_loop()
{
	sp_sc_flow_if number cvar _tet_spawn == val "1"
	{
		//reset the gate
		set _tet_spawn 0
		sp_sc_func_exec fn_tet_Spawn
		//check collision on new spawned object
		//that is victory/defeat condition
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_func_exec fn_tet_DoesCollide #_tet_seg_$i_x #_tet_seg_$i_y
			sp_sc_flow_if number cvar _tet_bool == val "1"
			{
				say "Game Over"
				sp_sc_func_exec .tetris_stop 0
			}
			add ~i 1
		}

	}
	else
	{
		//loop code here
		set ~collide 0
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_cvar_copy ~new_$i_y _tet_seg_$i_y
			add ~new_$i_y -1
			sp_sc_func_exec fn_tet_DoesCollide #_tet_seg_$i_x #~new_$i_y
			sp_sc_flow_if number cvar _tet_bool == val "1"
			{
				set ~collide 1
			}
			add ~i 1
		}
		sp_sc_flow_if number cvar ~collide == val "0"
		{
			//apply gravity
			set ~i 0
			sp_sc_flow_while number cvar ~i < val "4"
			{
				sp_sc_cvar_copy _tet_seg_$i_y ~new_$i_y
				add ~i 1
			}	
		}
		else
		{
			//landed on something, now we want to spawn next frame
			//also apply line destruction here, checking only lines that the last segment consisted of
			set ~i 0
			sp_sc_flow_while number cvar ~i < val "4"
			{
				sp_sc_cvar_copy ~tmp _tet_seg_$i_y
				set ~tmp _tet_jug_line_$~tmp
				sp_sc_flow_if number cvar #~tmp == val "1111111111"
				{
					sp_sc_cvar_copy ~j _tet_seg_$i_y;add ~j 1
					sp_sc_flow_while number cvar ~j < cvar _tet_jug_height
					{

					}
					_tet_seg_$i_y
					set #~tmp "0000000000"
				}
				add ~i 1
			}
			set _tet_spawn 1
		}
	}

	

	
	


   sp_sc_flow_if number cvar _tet_loop_run == val "1"
   {
       sp_sc_timer #_tet_loop_speed "sp_sc_func_exec fn_tet_loop"
   }
   else
   {
       set _tet_loop_busy 0
   }
}


function .tetris_left(~slot)
{
	set ~collide 0
	set ~i 0

	sp_sc_flow_while number cvar ~i < val "4"
	{
		sp_sc_cvar_copy ~new_$i_x _tet_seg_$i_x
		add ~new_$i_x -1
		sp_sc_func_exec fn_tet_DoesCollide #~new_$i_x #_tet_seg_$i_y
		sp_sc_flow_if number cvar _tet_bool == val "1"
		{
			set ~collide 1
		}
		add ~i 1
	}
	sp_sc_flow_if number cvar ~collide == val "0"
	{
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_cvar_copy _tet_seg_$i_x ~new_$i_x
			add ~i 1
		}
	}
}
function .tetris_right(~slot)
{
	set ~collide 0
	set ~i 0

	sp_sc_flow_while number cvar ~i < val "4"
	{
		sp_sc_cvar_copy ~new_$i_x _tet_seg_$i_x
		add ~new_$i_x 1
		sp_sc_func_exec fn_tet_DoesCollide #~new_$i_x #_tet_seg_$i_y
		sp_sc_flow_if number cvar _tet_bool == val "1"
		{
			set ~collide 1
		}
		add ~i 1
	}
	sp_sc_flow_if number cvar ~collide == val "0"
	{
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_cvar_copy _tet_seg_$i_x ~new_$i_x

			add ~i 1
		}
	}
}
//function .tetris_down(~slot)
//{
//	set ~i 0
//	sp_sc_flow_while number cvar ~i < val "4"
//	{
//
//	}
//}
//function .tetris_harddrop(~slot)
//{
//	set ~i 0
//	sp_sc_flow_while number cvar ~i < val "4"
//	{
//
//	}
//}
//clockwise
function .tetris_rotate1(~slot)
{

	set ~collide 0
	set ~i 0

	sp_sc_flow_while number cvar ~i < val "4"
	{
		//pX=pX+(pX-bX)
		//pY=pY+(pY-bY)
		//newoffY=oldoffX*-1
		//newoffX=oldoffY*-1 
		sp_sc_cvar_copy ~tmp_$i_x _tet_seg_$i_x
		sp_sc_cvar_copy ~tmp_$i_y _tet_seg_$i_y
		sp_sc_cvar_math_sub ~tmp_$i_x #_tet_seg_base_x
		sp_sc_cvar_math_sub ~tmp_$i_y #_tet_seg_base_y
		sp_sc_cvar_math_mul ~tmp_$i_x -1
		sp_sc_cvar_math_mul ~tmp_$i_y -1
		sp_sc_cvar_copy ~new_$i_x _tet_seg_base_x
		sp_sc_cvar_copy ~new_$i_y _tet_seg_base_y
		add ~new_$i_x #~tmp_$i_x
		add ~new_$i_y #~tmp_$i_y
		sp_sc_cvar_copy ~new_$i_x _tet_seg_$i_y;
		sp_sc_cvar_copy ~new_$i_y _tet_seg_$i_x;
		sp_sc_func_exec fn_tet_DoesCollide #~new_$i_x #~new_$i_y
		sp_sc_flow_if number cvar _tet_bool == val "1"
		{
			set ~collide 1
		}
		add ~i 1
	}
	sp_sc_flow_if number cvar ~collide == val "0"
	{
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_cvar_copy _tet_seg_$i_x ~new_$i_x
			sp_sc_cvar_copy _tet_seg_$i_y ~new_$i_y
			add ~i 1
		}
	}
}
//anticlockwise
function .tetris_rotate2(~slot)
{
	set ~collide 0
	set ~i 0

	sp_sc_flow_while number cvar ~i < val "4"
	{
		//pX=pX+(pX-bX)
		//pY=pY+(pY-bY)
		//newoffY=oldoffX
		//newoffX=oldoffY*-1 
		sp_sc_cvar_copy ~tmp_$i_x _tet_seg_$i_x
		sp_sc_cvar_copy ~tmp_$i_y _tet_seg_$i_y
		sp_sc_cvar_math_sub ~tmp_$i_x #_tet_seg_base_x
		sp_sc_cvar_math_sub ~tmp_$i_y #_tet_seg_base_y
		sp_sc_cvar_math_mul ~tmp_$i_x -1
		sp_sc_cvar_math_mul ~tmp_$i_y -1
		sp_sc_cvar_copy ~new_$i_x _tet_seg_base_x
		sp_sc_cvar_copy ~new_$i_y _tet_seg_base_y
		add ~new_$i_x #~tmp_$i_x
		add ~new_$i_y #~tmp_$i_y
		sp_sc_cvar_copy ~new_$i_x _tet_seg_$i_y;
		sp_sc_cvar_copy ~new_$i_y _tet_seg_$i_x;
		sp_sc_func_exec fn_tet_DoesCollide #~new_$i_x #~new_$i_y
		sp_sc_flow_if number cvar _tet_bool == val "1"
		{
			set ~collide 1
		}
		add ~i 1
	}
	sp_sc_flow_if number cvar ~collide == val "0"
	{
		set ~i 0
		sp_sc_flow_while number cvar ~i < val "4"
		{
			sp_sc_cvar_copy _tet_seg_$i_x ~new_$i_x
			sp_sc_cvar_copy _tet_seg_$i_y ~new_$i_y
			add ~i 1
		}
	}
}